````markdown
# Домашнє завдання №9 — Жадібні алгоритми та динамічне програмування

У цьому завданні реалізовано дві функції для розв'язання задачі видачі решти покупцеві:

---

## Функція `find_coins_greedy(amount)`

Реалізує жадібний алгоритм.

- Завжди вибирає найбільший доступний номінал монети, який не перевищує залишок суми.
- Швидко працює для великих сум.
- Не гарантує мінімальну кількість монет у нестандартних наборах монет.

**Приклад:**

```python
find_coins_greedy(113)
# ➜ {50: 2, 10: 1, 2: 1, 1: 1}
````

---

## Функція `find_min_coins(amount)`

Реалізує алгоритм динамічного програмування.

* Знаходить мінімальну кількість монет, необхідних для досягнення заданої суми.
* Використовує таблицю, щоб зберігати проміжні результати.
* Завжди повертає оптимальне рішення незалежно від набору монет.

**Приклад:**

```python
find_min_coins(113)
# ➜ {1: 1, 2: 1, 10: 1, 50: 2}
```

---

## Порівняння ефективності

| Алгоритм                    | Складність                                      | Швидкодія                            | Оптимальність рішень  |
| --------------------------- | ----------------------------------------------- | ------------------------------------ | --------------------- |
| **Жадібний**                | O(n), де n — кількість номіналів                | Висока (дуже швидкий)                | Не завжди оптимальний |
| **Динамічне програмування** | O(n \* m), де n — сума, m — кількість номіналів | Нижча (повільніше при великих сумах) | Завжди оптимальний    |

---

## Поведінка при великих сумах

* **Жадібний алгоритм** працює дуже швидко навіть при великих значеннях суми, бо перебирає номінали лише один раз. Підходить для реальних валютних систем, де набір монет дозволяє жадібному алгоритму давати оптимальний результат.
* **Динамічне програмування** забезпечує правильність результату, але витрачає більше пам’яті та часу. Особливо це помітно при сумах у тисячі й більше — кожну суму до `n` потрібно прораховувати з усіма номіналами.

---

## Висновок

Жадібний алгоритм є ефективним і швидким у практичних умовах, особливо коли набір монет «гармонійний».
Алгоритм динамічного програмування гарантує мінімальну кількість монет для будь-якого набору номіналів, хоч і вимагає більше ресурсів.

У ситуаціях, де важлива швидкість і простота — варто використовувати жадібний підхід.
У задачах, де пріоритет — оптимальність (наприклад, нестандартні валюти чи автоматичний аналіз) — краще застосовувати динамічне програмування.

```
